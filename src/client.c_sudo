#include <dbutil.h>
#include <seedutil.h>
#include <rsautil.h>
#include <json-c/json.h>

#define DB_NAME "/home/shryu/sqliteDB/card.db"

int doProcess(sqlite3 *db, const char *path_json, const int index, card_pay_info_t *pCpi, int *exitflag);
int getPayInfo(char *pathfile_json, card_pay_info_t *pCpi, int *exitflag);
int convJSONtoPAYINFO(card_pay_info_t *pCpi, json_object *pObj);
int procReqInfo(sqlite3 *db, card_pay_info_t *pCpi);
int selPayinfo(sqlite3 *db);
int showCPI(const char *val);

void showCardPayInfo(card_pay_info_t *pCpi, char *pathfile)
{
	fprintf(stderr, "-------- %s ---------\n", pathfile);
	fprintf(stderr, "ssl_len    [%d] \n", pCpi->ssl_len    );
	fprintf(stderr, "req_cd     [%s] \n", pCpi->req_cd     );
	fprintf(stderr, "mng_no     [%s] \n", pCpi->mng_no     );
	fprintf(stderr, "card_no    [%ld]\n", pCpi->card_no    );
	fprintf(stderr, "istm_cd    [%s] \n", pCpi->istm_cd    );
	fprintf(stderr, "expr_mmyy  [%s] \n", pCpi->expr_mmyy  );
	fprintf(stderr, "cvc        [%s] \n", pCpi->cvc        );
	fprintf(stderr, "pay_amt    [%ld]\n", pCpi->pay_amt    );
	fprintf(stderr, "vat        [%ld]\n", pCpi->vat        );
	fprintf(stderr, "org_mng_no [%s] \n", pCpi->org_mng_no );
	fprintf(stderr, "enc_info   [%s] \n", pCpi->enc_info   );
	fprintf(stderr, "filler     [%s] \n", pCpi->filler     );
	fprintf(stderr, "---------------------------------------------\n");
}

int main(int argc, char *argv[])
{
	int exitflag = 0;
	int index = 0;
	char path_json[512 + 1];

	sqlite3 *db;
	card_pay_info_t cpi;

	sprintf(path_json, "%s/req", getenv("SH_HOME"));
	fprintf(stderr, "path_json[%s]\n", path_json);

	if (sh_dbcon(DB_NAME, &db) < 0) {
		return -1;
	}

	while (!exitflag) {
		if (doProcess(db, path_json, index, &cpi, &exitflag) < 0) {
			break;
		}
		index++;

	}
	
	// 조회
	if (selPayinfo(db) < 0) {
		sh_dbdiscon(db);
		return -1;
	}

	sh_dbdiscon(db);

	fprintf(stderr, "프로그램이 종료되었습니다.\n");

	return 0;
}

int doProcess(sqlite3 *db, const char *path_json, const int index, card_pay_info_t *pCpi, int *exitflag)
{
	char pathfile_json[1024 + 1];

	sprintf(pathfile_json, "%s/req_%02d.json", path_json, index);
	fprintf(stderr, ">>>pathfile_json[%s]\n", pathfile_json);

	// 요청정보 조회
	if (getPayInfo(pathfile_json, pCpi, exitflag) < 0) {
		return -1;
	}
	if (*exitflag) return 0;

	// 요청정보 처리
	if (procReqInfo(db, pCpi) < 0) {
		return -1;
	}

	return 0;
}

int getPayInfo(char *pathfile_json, card_pay_info_t *pCpi, int *exitflag)
{
	json_object *obj = NULL;

	if ((obj = json_object_from_file(pathfile_json)) == NULL) {
		*exitflag = 1;
		fprintf(stderr, "no data found. pathfile_json[%s] --> finished (%s)\n", pathfile_json, json_util_get_last_err());
		return 0;
	}

	if (convJSONtoPAYINFO(pCpi, obj) < 0) {
		return -1;
	}

	showCardPayInfo(pCpi, pathfile_json);

	// 자원 해제
	json_object_put(obj);

	return 0;
}

int convJSONtoPAYINFO(card_pay_info_t *pCpi, json_object *pObj)
{
	int str_len = 0;
	static long mng_num = 1;

	int declen, enclen;
	unsigned char decbuf[1024 + 1];
	unsigned char encbuf[1024 + 1];

	json_object *obj_val;

	memset(decbuf, 0x00, sizeof(decbuf));
	memset(encbuf, 0x00, sizeof(encbuf));
	memset(pCpi, 0x00, sizeof(card_pay_info_t));

	// ssl_len
	pCpi->ssl_len = 446;

	// req_cd
	if ((obj_val = json_object_object_get(pObj, "Req_cd")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Req_cd] (%s)\n", json_util_get_last_err());
		return -1;
	}

	str_len = strlen(json_object_get_string(obj_val));
	if (str_len != 6 && str_len != 7) {
		fprintf(stderr, "[ERROR] Invalid length[%d] of req_cd[%s]\n", str_len, json_object_get_string(obj_val));
		return -1;
	}
	memcpy(pCpi->req_cd, json_object_get_string(obj_val), str_len);

	// mng_no
	sprintf(pCpi->mng_no, "%020ld", mng_num++);

	// card_no
	if ((obj_val = json_object_object_get(pObj, "Card_no")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Card_no] (%s)\n", json_util_get_last_err());
		return -1;
	}

	pCpi->card_no = json_object_get_int64(obj_val);
	if (pCpi->card_no < 1000000000) {
		fprintf(stderr, "[ERROR] Invalid card_no[%ld]\n", pCpi->card_no);
		return -1;
	}

	// installment code
	if ((obj_val = json_object_object_get(pObj, "Istm_cd")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Istm_cd] (%s)\n", json_util_get_last_err());
		return -1;
	}

	str_len = strlen(json_object_get_string(obj_val));
	fprintf(stderr, "%d;%s]\n", str_len, json_object_get_string(obj_val));
	if (str_len != 2) {
		fprintf(stderr, "[ERROR] Invalid length[%d] of istm_cd.\n", str_len);
		return -1;
	}
	memcpy(pCpi->istm_cd, json_object_get_string(obj_val), str_len);

	// expr_mmyy
	if ((obj_val = json_object_object_get(pObj, "Expr_mmyy")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Expr_mmyy] (%s)\n", json_util_get_last_err());
		return -1;
	}

	str_len = strlen(json_object_get_string(obj_val));
	if (str_len != 4) {
		fprintf(stderr, "[ERROR] Invalid length[%d] of expr_mmyy.\n", str_len);
		return -1;
	}
	memcpy(pCpi->expr_mmyy, json_object_get_string(obj_val), str_len);

	// cvc
	if ((obj_val = json_object_object_get(pObj, "Cvc")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Cvc] (%s)\n", json_util_get_last_err());
		return -1;
	}

	str_len = strlen(json_object_get_string(obj_val));
	if (str_len != 3) {
		fprintf(stderr, "[ERROR] Invalid length[%d] of cvc.\n", str_len);
		return -1;
	}
	memcpy(pCpi->cvc, json_object_get_string(obj_val), str_len);

	// pay_amt 
	if ((obj_val = json_object_object_get(pObj, "Pay_amt")) == NULL) {
		fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Pay_amt] (%s)\n", json_util_get_last_err());
		return -1;
	}

	pCpi->pay_amt = json_object_get_int64(obj_val);
	if (pCpi->pay_amt < 100 || pCpi->pay_amt > 9999999999) {
		fprintf(stderr, "[ERROR] Invalid pay_amt[%ld]\n", pCpi->pay_amt);
		return -1;
	}

	// vat 
	if ((obj_val = json_object_object_get(pObj, "Vat")) == NULL) {
		pCpi->vat = round((double)pCpi->pay_amt / 11);

	} else {
		pCpi->vat = json_object_get_int64(obj_val);
		if (pCpi->vat > pCpi->pay_amt) {
			fprintf(stderr, "[ERROR] Invalid vat[%ld] > pCpi->pay_amt[%ld]\n", pCpi->vat, pCpi->pay_amt);
			return -1;
		}
	}

	// org_mng_no
	if (memcmp(pCpi->req_cd, "CANCEL", 6) == 0) {
		if ((obj_val = json_object_object_get(pObj, "Org_mng_no")) == NULL) {
			fprintf(stderr, "[ERROR]json_object_object_get() fail. key[Org_mng_no] (%s)\n", json_util_get_last_err());
			return -1;
		}

		str_len = strlen(json_object_get_string(obj_val));
		if (str_len != 20) {
			fprintf(stderr, "[ERROR] Invalid length[%d] of org_mng_no.\n", str_len);
			return -1;
		}
		memcpy(pCpi->org_mng_no, json_object_get_string(obj_val), str_len);

	} else {
		memset(pCpi->org_mng_no, 0x20, sizeof(pCpi->org_mng_no) - 1);
	}

	// enc_info
	sprintf((char *)decbuf, "%ld|%s|%s", pCpi->card_no, pCpi->expr_mmyy, pCpi->cvc);
	declen = strlen((char *)decbuf);

	if (sh_encrypt(decbuf, declen, encbuf, &enclen, pCpi) < 0) {
		return -1;
	}
	memcpy(pCpi->enc_info, encbuf, enclen);
	fprintf(stderr, "decbuf[%d:%s] encbuf[%d:%s]\n", declen, decbuf, enclen, encbuf);

	memset(pCpi->enc_info, 0x20, sizeof(pCpi->enc_info) - 1);
	memcpy(pCpi->enc_info, encbuf, enclen);

	// 복호화 테스트
	if (sh_decrypt(encbuf, enclen, decbuf, &declen, pCpi) < 0) {
		return -1;
	}
	
	// filler
	memset(pCpi->filler, 0x20, sizeof(pCpi->filler) - 1);

	return 0;
}

/*
 * pos: L(left) R(right)
 */
void ltos_padding(long org, char *dest, const int dest_len, const char ch, const char pos)
{
	int strtmp_len;
	char strtmp [dest_len + 1];

	memset(strtmp , 0x00, sizeof(strtmp));

	sprintf(strtmp, "%ld", org);
	strtmp_len = strlen(strtmp);

	if (pos == 'R') {
		memset(strtmp + strtmp_len, ch, dest_len - strtmp_len);

		memcpy(dest, strtmp, dest_len);
	} else if (pos == 'L') {
		char strtmp2[dest_len + 1];
		memset(strtmp2, ch, sizeof(strtmp2));
		strtmp2[dest_len] = 0x00;

		memcpy(strtmp2 + dest_len - strtmp_len, strtmp, strtmp_len);

		memcpy(dest, strtmp2, dest_len);
	}

	return;
}

void stos_padding(char *org, const int org_len, char *dest, const int dest_len, const char ch)
{
	if (org_len > dest_len) {
		memcpy(dest, org, org_len);
	} else {
		memset(dest, ch, dest_len);
		memcpy(dest, org, org_len);
	}
	return;
}

int procReqInfo(sqlite3 *db, card_pay_info_t *pCpi)
{
	int reqlen = 0;

	char szReqbuf [450 + 1];

	char szReq_cd  [ 10 + 1];
	char szCard_no [ 20 + 1];
	char szPay_amt [ 20 + 1];
	char szVat     [ 10 + 1];
	char szEnc_info[300 + 1];

	memset(szReqbuf , 0x00, sizeof(szReqbuf ));

	memset(szReq_cd  , 0x00, sizeof(szReq_cd  ));
	memset(szCard_no , 0x00, sizeof(szCard_no ));
	memset(szPay_amt , 0x00, sizeof(szPay_amt ));
	memset(szVat     , 0x00, sizeof(szVat     ));
	memset(szEnc_info, 0x00, sizeof(szEnc_info));

	stos_padding(pCpi->req_cd  , strlen(pCpi->req_cd), szReq_cd, 10, ' ');
	ltos_padding(pCpi->card_no , szCard_no, 20, ' ', 'R');
	ltos_padding(pCpi->pay_amt , szPay_amt, 10, ' ', 'L');
	ltos_padding(pCpi->vat     , szVat    , 10, '0', 'L');
	stos_padding(pCpi->enc_info, strlen(pCpi->enc_info), szEnc_info, 300, ' ');

	sprintf(szReqbuf        , "%04d"           ,  pCpi->ssl_len); reqlen +=   4; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, szReq_cd         ,  10           ); reqlen +=  10; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, pCpi->mng_no     ,  20           ); reqlen +=  20; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, szCard_no        ,  20           ); reqlen +=  20; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, pCpi->istm_cd    ,   2           ); reqlen +=   2; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, pCpi->expr_mmyy  ,   4           ); reqlen +=   4; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, pCpi->cvc        ,   3           ); reqlen +=   3; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, szPay_amt        ,  10           ); reqlen +=  10; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, szVat            ,  10           ); reqlen +=  10; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, pCpi->org_mng_no ,  20           ); reqlen +=  20; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memcpy(szReqbuf + reqlen, szEnc_info       , 300           ); reqlen += 300; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);
	memset(szReqbuf + reqlen, 0x20             ,  47           ); reqlen +=  47; fprintf(stderr, "szReqbuf[%03ld:%s]\n", strlen(szReqbuf), szReqbuf);

	// db write
	if (sh_ins_data(db, szReqbuf) < 0) {
		return -1;
	}

	return 0;
}

int selPayinfo(sqlite3 *db)
{
	int ret;

	char sql[1024];
	char val[450 + 1];
	sqlite3_stmt *stmt;

	memset(sql, 0x00, sizeof(sql));

	strcpy(sql, "SELECT * FROM TB_PAYINFO_STRING");
	
	if (sh_cur_open(db, sql, strlen(sql), &stmt) < 0) {
		return -1;
	}

	while (1) {
		if ((ret = sh_cur_fetch(stmt, val)) < 0) {
			sh_cur_close(stmt);
			return -1;
		} else if (ret == 1) break;

		showCPI(val);
	}

	sh_cur_close(stmt);
	return 0;
}

int sh_stoi(const char *str, const int len, int *num)
{
    int i, j;

    if (len < 1) {
		return -1;
	}

    *num = 0;
    for (i = 0; i < len; i++) {
        if (str[i] < '0' || str[i] > '9') {
            return -1;
        }
        if (str[i] != '0') break;
    }

    if (i < len) {
        *num = str[i] - '0';

        for (j = i + 1; j < len; j++) {
            if (str[i] < '0' || str[i] > '9') {
                return -1;
            }

            *num = *num * 10 + (str[j] - '0');
        }
    }

	return 0;
}

int sh_stol(const char *str, const int len, long *num)
{
    int i, j;

    if (len < 1) {
		return -1;
	}

    *num = 0;
    for (i = 0; i < len; i++) {
        if (str[i] < '0' || str[i] > '9') {
            return -1;
        }
        if (str[i] != '0') break;
    }

    if (i < len) {
        *num = str[i] - '0';

        for (j = i + 1; j < len; j++) {
            if (str[i] < '0' || str[i] > '9') {
                return -1;
            }

            *num = *num * 10 + (str[j] - '0');
        }
    }

	return 0;
}

void stos_unpadding(const char *org, const int org_len, char *dest, const char ch, const char pos)
{
	int i;
	char strtmp[org_len + 1];

	memset(strtmp, 0x00, sizeof(strtmp));

	memcpy(strtmp, org, org_len);

	if (pos == 'L') {
		for (i = 0; i < org_len; i++) {
			if (strtmp[i] != ch) break;
		}

		memcpy(dest, strtmp + i, org_len - i);
	} else if (pos == 'R') {
		for (i = org_len - 1; i >= 0; i--) {
			if (strtmp[i] != ch) break;
		}

		memcpy(dest, strtmp, i + 1);
	}

	return;
}

void stol_unpadding(const char *org, const int org_len, long *dest, const char ch, const char pos)
{
	int i;
	char strtmp [org_len + 1];
	char strtmp2[org_len + 1];

	memset(strtmp , 0x00, sizeof(strtmp ));
	memset(strtmp2, 0x00, sizeof(strtmp2));

	memcpy(strtmp, org, org_len);

	if (pos == 'L') {
		for (i = 0; i < org_len; i++) {
			if (strtmp[i] != ch) break;
		}

		memcpy(strtmp2, strtmp + i, org_len - i);
		*dest = atol(strtmp2);
	} else if (pos == 'R') {
		for (i = org_len - 1; i >= 0; i--) {
			if (strtmp[i] != ch) break;
		}

		memcpy(strtmp2, strtmp, i + 1);
		*dest = atol(strtmp2);
	}

	return;
}

int showCPI(const char *val)
{
	int offset, dec_len;

	unsigned char szEnc_info[D_SIZE_ENC_INFO + 1];
	unsigned char szDec_info[D_SIZE_ENC_INFO + 1];
	memset(szEnc_info, 0x00, sizeof(szEnc_info));
	memset(szDec_info, 0x00, sizeof(szDec_info));

	card_pay_info_t cpi, *pCpi;

	pCpi = &cpi;

	memset(pCpi, 0x00, sizeof(card_pay_info_t));

	offset = 0;
	sh_stoi(val + offset, D_SIZE_SSL_LEN, &pCpi->ssl_len);                         offset += D_SIZE_SSL_LEN;
	stos_unpadding(val + offset, D_SIZE_REQ_CD, pCpi->req_cd, ' ', 'R');           offset += D_SIZE_REQ_CD;
	memcpy(pCpi->mng_no, val + offset, D_SIZE_MNG_NO);                             offset += D_SIZE_MNG_NO;
	stol_unpadding(val + offset, D_SIZE_CARD_NO, &pCpi->card_no, ' ', 'R');        offset += D_SIZE_CARD_NO;
	memcpy(pCpi->istm_cd, val + offset, D_SIZE_ISTM_CD);                           offset += D_SIZE_ISTM_CD;
	memcpy(pCpi->expr_mmyy, val + offset, D_SIZE_EXPR_MMYY);                       offset += D_SIZE_EXPR_MMYY;
	memcpy(pCpi->cvc      , val + offset, D_SIZE_CVC      );                       offset += D_SIZE_CVC;
	stol_unpadding(val + offset, D_SIZE_PAY_AMT   , &pCpi->pay_amt   , ' ', 'L');  offset += D_SIZE_PAY_AMT;
	stol_unpadding(val + offset, D_SIZE_VAT       , &pCpi->vat       , '0', 'L');  offset += D_SIZE_VAT;
	stos_unpadding(val + offset, D_SIZE_ORG_MNG_NO,  pCpi->org_mng_no, ' ', 'R');  offset += D_SIZE_ORG_MNG_NO;
	showCardPayInfo(pCpi, "showCPI");
	stos_unpadding(val + offset, D_SIZE_ENC_INFO, (char *)szEnc_info, ' ', 'R'); offset += D_SIZE_ENC_INFO;
	fprintf(stderr, "shryuA: szEnc_info[%ld:%s]\n", strlen((char *)szEnc_info), szEnc_info);

	if (sh_decrypt(szEnc_info, strlen((char *)szEnc_info), szDec_info, &dec_len, pCpi) < 0) {
		return -1;
	}

	fprintf(stderr, "shryuB: szDec_info[%d:%s]\n", dec_len,  szDec_info);


	return 0;
}
